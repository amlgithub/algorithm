<span style='color:red; font-size: 18px;'>**体变大，加颜色**</span>

```xml
<span style='color:red; font-size: 18px;'>**字体变大，加颜色**</span>
```

### 1. 一维数组

​	一维数组在内存中占据连续的空间，可以用“下标”定位对应的元素；

### 2. 二维数组

​	二维数组在内存中占据连续的空间。在内存中从上到下存储各行元素，在同一列中按照从左到右的顺序存储。

​	因此，可以根据行号和列号找到对应的元素。

### 3. 字符串

​	1. 字符串是固定大小的，要注意 内存覆盖的情况。**一般从前到后替换，移动次数较多时，要想到，从后往前移动** 

### 数组和字符串 技巧

​	<span style='color:red; font-size: 18px;'>**在合并两个数组（包括字符串）时，如果从前往后复制每个数字（或字符）则需要重复移动数字（或字符）多次， 那么，我们可以考虑从后往前复制，这样就能减少移动的次数，从而提高效率**</span>

### 4. 链表

**链表：只要记住，知道第一个节点后，其他节点可通过next域依次找到**

```java
//1. 第一种
// 新建一个头结点,固定设置一个值
		ListNode head = new ListNode(0);
		/**
		 * 这个是新链表的尾节点
		 */
		ListNode cur = head;//这个是新链表的尾节点

	这里返回应该是 return hear.next;
===================
//2. 第二种，直接将链表赋值为空
ListNode pMergeHead = null;//这样就不能再有，pMergeHead.next = nul;不然回报空指针异常
```

关于头结点和头指针**

<https://www.jianshu.com/p/580ddaca13d5>  

**有时在单链表的第一个结点之前附设一个结点，称之为头结点 。 头结点的数据域可以不存储任何信息，也可以存储如线性表长度等类的附加信息，头结点的指针域存储指向第一个结点的指针（即第一个元素结点的存储位置）。如图２(a)所示，此时，单链表的头指针指向头结点。若线性表为空，则头结点的指针域为“空”，如图２(b)所示。**

![1111](H:\综艺\1111.png)

[单链表为什么要设置头结点](https://link.jianshu.com?t=http%3A%2F%2Fwww.cnblogs.com%2Fyouxin%2Fp%2F3279391.html)

问题：在单链表中使用“头结点”，这个哑结点始终是链表的第一个元素，这个技巧的利与弊？

链表中第一个结点的存储位置叫做头指针，那么整个链表的存取就必须从头指针开始进行了。之后的每一个结点，其实就是上一个的后继指针指向的位置。
 **链表中第一个结点的存储位置叫做头指针**
 头指针和头结点不同，头结点即第一个结点，头指针是指向第一个结点的指针。链表中可以没有头结点，但不能没有头指针。
 如果链表有头结点，那么头指针就是指向头结点数据域的指针。




![img](https:////upload-images.jianshu.io/upload_images/4085087-e25ee63d9a715103.png?imageMogr2/auto-orient/strip|imageView2/2/w/651/format/webp)

链表头结点和头指针



单链表也可以没有头结点，没有头结点的单链表



![img](https:////upload-images.jianshu.io/upload_images/4085087-4090259b7d145b11.png?imageMogr2/auto-orient/strip|imageView2/2/w/482/format/webp)

没有头结点的单链表

-  [头结点](https://link.jianshu.com?t=http%3A%2F%2Fwww.nowamagic.net%2Flibrarys%2Fveda%2Ftag%2F%E5%A4%B4%E7%BB%93%E7%82%B9)是为了操作的统一与方便而设立的，放在第一个元素结点之前，其数据域一般无意义（当然有些情况下也可存放链表的长度、用做监视哨等等）。
- 有了头结点后，对在第一个元素结点前插入结点和删除第一个结点，其操作与对其它结点的操作统一了。
- 首元结点也就是第一个元素的结点，它是头结点后边的第一个结点。
- 头结点不是链表所必需的
- 在线性表的链式存储结构中，头指针是指链表指向第一个结点的指针，若链表有头结点，则头指针就是指向链表头结点的指针。
- 头指针具有标识作用，故常用头指针冠以链表的名字。
- 无论链表是否为空，头指针均不为空，头指针是链表的必要元素

为了使空链表与非空链表处理一致，我们通常设一个头结点。

一、两者区别：
 1、不带头结点的单链表对于第一个节点的操作与其他节点不一样，需要特殊处理，这增加了程序的复杂性和出现bug的机会，因此，**通常在单链表的开始结点之前附设一个头结点。**
 2、带头结点的单链表,初始时一定返回的是指向头结点的地址，所以一定要用二维指针，否则将导致内存访问失败或异常。
 3、带头结点与不带头结点初始化、插入、删除、输出操作都不样，在遍历输出链表数据时，带头结点的判断条件是while(head->next!=NULL)，
 而不带头结点是while(head!=NULL)，虽然头指针可以在初始时设定，但是如1所述，对于特殊情况如只有一个节点会出现问题。

<http://data.biancheng.net/view/103.html>

![img](http://data.biancheng.net/uploads/allimg/180504/2-1P504152005N4.png)

```java
头指针
头指针，是指向链表中一个结点所在存储位置的指针。如果链表中有头结点，则头指针指向头结点；若链表中没有头结点，则头指针指向链表中第一个数据结点（也叫首元结点）。

由于使用链表存储的数据，其真实的物理存储地址并没有相互紧挨着（数组的存储空间是紧挨着的），而是由系统随机分配。所以为了能够方便地找到链表中存储的数据，为链表创建头指针就显得至为重要。

链表有头指针，当我们需要使用链表中的数据时，我们可以使用遍历查找等方法，从头指针指向的结点开始，依次搜索，直到找到需要的数据；反之，若没有头指针，则链表中的数据根本无法使用，也就失去了存储数据的意义。
在计算机中，数据的存储是为了更方便地使用，一切不以使用为目向计算机中存储的数据都是垃圾数据。
头结点
头结点，位于链表的表头，即链表中第一个结点，其一般不存储任何数据，特殊情况可存储表示链表信息（表的长度等）的数据。

头结点的存在，其本身没有任何作用，就是一个空结点，但是在对链表的某些操作中，链表有无头结点，可以直接影响编程实现的难易程度。

例如，若链表无头结点，则对于在链表中第一个数据结点之前插入一个新结点，或者对链表中第一个数据结点做删除操作，都必须要当做特殊情况，进行特殊考虑；而若链表中设有头结点，以上两种特殊情况都可被视为普通情况，不需要特殊考虑，降低了问题实现的难度。

链表有头结点，也不一定都是有利的。例如解决约瑟夫环问题，若链表有头结点，在一定程度上会阻碍算法的实现。

所以，对于一个链表来说，设置头指针是必要且必须的，但有没有头结点，则需要根据实际问题特殊分析。
```



```java
链表中 新建一个节点指向头结点
 ListNode pN = new ListNode(0);// 新增加的pN节点；头结点
			pN.next = head;//指向链表中第一节点
	==============================		
和直接指向头结点方式
  ListNode cur = head;//直接定一个节点执行当前头结点；不新建一个节点执行头结点
```

	1. 链表只能 遍历才能访问所有的节点，链表的内存不是一次性分配的，无法保证链表的内容和数组一样是连续的。
 	2. 链表题，多想想，输入和输出的关系，看能用哪种数据结构，例如栈、队列等；**链表反转用的就是 “栈”**
 	3. 如果想到用 栈，**而递归本质就是一个栈结构**，就可以用递归来实现。

### 5. 二叉树

**求mid = (L+R)/2 == L + (R-L)/2**

	1. 要对二叉树的3种遍历的6种实现方法，了如指掌。3种遍历都有递归和循环两种实现方式。
 	2. 二叉树有很多特例，二叉搜索树：左子节点总是**小于或等于**根节点，而右子节点总是**大于等于**根节点。在O（logn）的时间内根据数值在二叉搜索树中找到一个节点。
 	3. 二叉数的其他特例，红黑树和堆。堆分为**大根堆和小根堆**，大根堆中根节点的值最大，在最小堆中，根节点的值最小。
 	4. 红黑树：是把树中的节点定义为红、黑两种颜色，**并通过规则确保从根节点到叶节点的最长路径的长度不超过最短路径的两倍。**
 	5. 构建二叉树，可以将大问题分解构建左右子树的两个小问题。发现小问题和大问题的本质是一致的，因此用递归来解决。

**中序遍历的下一个节点求法：**

```java
	中序下一个接有三种情况：
	 * 	①： 如果一个节点有右子树，则下一个节点，就是他右子树中最左节点；
	 * 		即，从右节点出发一直沿着左子节点的指针，
	 * 	如果一个节点没有右子树，则又分为两种情况：
	 * 		②：一个节点没有右子树，并且还是他父节点的 左孩子，则，他的父节点就是他的 下一个节点；
	 * 		③：一个节点没有右孩子，并且还是他父节点的右孩子，则，情况有点复杂，沿着父节点的指针一直向上遍历，
	 * 			直到找到当前节点是其父节点的左孩子。如果没有找到，则没有下一个节点	
```

### 6. 递归

	1. 递归的本质：把一个问题分解为两个或多个小问题。如果多个小问题存在相互重叠的部分，就存在重复的计算。
 	2. dp动态规划，都是应用递归的思路分析问题，但是递归分解子问题中存在大量的重复，**因此我们总是用自下而上的循环来实现代码。**
 	3. 递归是在一个函数的内部调用这个函数自身，而循环则是通过设置计算的初始值及终止条件，在一个范围内重复运算。

### 7. 查找和排序

	1. **在排序的数组或者部分排序的数组中查找一个数字或统计某个数字出现的次数，都可以用二分查找法。**

 	2. 哈希表最主要的优点是能够在O（1）时间内查找某一个元素，是效率最高的查找方式，确定需要额外空间。

### 8. 回溯+深搜

​	看第10题，这个一个模板题

### 9. 动态规划 dp

```java
/**
	越界考虑情况：
	 * 动态规划，遍历矩阵即可，无需考虑越界
	 *  DFS / BFS 由于都是”朝某方向“搜索，因此在撞到边界时（越界时），就应返回，我们称之为剪枝。
	 *  动态规划则是直接遍历列表或者矩阵，在遍历中使用转移方程计算，因此就没有越界的概念啦~
	 */
```

	1. 如果是求一个问题的最优解（通常是求最大值或者最小值），而且该问题能够分解成若干个子问题，并且子问题之间还有重叠的更小子问题，就可以用dp；
 	2. 用之前要分析能够把大问题分解成小问题，**分解后每个小问题也存在最优解**。如果把小问题的最优解组合起来能够得到整个问题的最优解。则可以用dp。
 	3. dp：从上往下分析问题， 从下往上求解问题。
 	4. dp：由于事先**不知道哪个是最优解法**，因此只好把**所有的可能都尝试一遍，然后比较得出最优解法。**如果用数学的语言来表示，就是f(n) = max(f(i) * f(n-i)),其中，0<i<n

### 10. 位运算

 1. 异或： 0^0=0 ; 1^0=1; 0^1=1; 1^1=0;

 2. 左移： m << n :表示把m左移n位。在左移n位的时候，最左边的n位将被丢弃，同时在最右边补上n个0；

    例如： 00001010 << 2 = 00101000

	3. 右移： m >> n :表示把m右移n位。在右移n位的时候，最右边n位将被丢弃，同时最左边分两种情况，

    	1. 最左边开头数字为0（正数）：则用0填补最左边的n位；
    	2. 最左边开头数字为1（负数）：则用1填补最左边的n位；
    
 3. java中各种类型的 位数情况

```java
一、分析基本数据类型的特点，最大值和最小值。
1、
基本类型：int 二进制位数：32
包装类：java.lang.Integer
最小值：Integer.MIN_VALUE= -2147483648 （-2的31次方）
最大值：Integer.MAX_VALUE= 2147483647  （2的31次方-1）
2、
基本类型：short 二进制位数：16
包装类：java.lang.Short
最小值：Short.MIN_VALUE=-32768 （-2的15此方）
最大值：Short.MAX_VALUE=32767 （2的15次方-1）
3、
基本类型：long 二进制位数：64
包装类：java.lang.Long
最小值：Long.MIN_VALUE=-9223372036854775808 （-2的63次方）
最大值：Long.MAX_VALUE=9223372036854775807 （2的63次方-1）
4、
基本类型：float 二进制位数：32
包装类：java.lang.Float
最小值：Float.MIN_VALUE=1.4E-45 （2的-149次方）
最大值：Float.MAX_VALUE=3.4028235E38 （2的128次方-1）
5、
基本类型：double 二进制位数：64
包装类：java.lang.Double
最小值：Double.MIN_VALUE=4.9E-324 （2的-1074次方）
最大值：Double.MAX_VALUE=1.7976931348623157E308 （2的1024次方-1）
==============================================================
byte(字节)／8／-128 - 127
shot(短整型)／16／-32768 - 32767
int(整型)／32／-2147483648-2147483647
long(长整型)／64／-9233372036854477808-9233372036854477807
float(浮点型)／32／-3.40292347E+38-3.40292347E+38／0.0f
double(双精度)／64／-1.79769313486231570E+308-1.79769313486231570E+308／0.0d
char(字符型)／16 ／‘ \u0000 - u\ffff ’ ／‘\u0000 ’
boolean(布尔型)／1／true/false／false
```

​			两个正数 &（相与），则是，先将数都转为二进制，然后，一一对应相与
​			 * 例如： 5 & 1 ==》 101 & 001则结果为001（二进制），就是正数1

​	右移运算代替了 除以2； 用位与运算符号代替了 %2

### 11. 链表

 1. **链表的删除**

    在链表中删除一个节点，通常有两种方法：

    例如链表：	a -> b ->... h-> **i** -> j ->...

    ​	1） 在删除 i 节点之前，先从链表的头节点开始遍历到 i前面的一个节点 h，把h的next指针指向 i的下一个节点 j, 再删除节点 i

    ​	2） 把节点 j 的内容复制覆盖节点 i， 接下来再把节点 i的 next指针指向 j的下一个节点，再删除节点 j。

    这种方法需要考虑一个特殊情况：如果**要删除的节点为链表的尾部**，那么他就没有下一个节点。**怎么办？， 我们仍然从链表的头结点开始，顺序遍历得到该节点的前序节点，并完成删除操作。**

    **这种**方法不用遍历链表上节点i前面的节点。

![这里写图片描述](https://img-blog.csdn.net/20160420141138723)

​			head头结点没有数据；

```java
一个链表头节点为head

head     1     2     3     4     5     6

head叫做链表的头节点

1所在的节点叫做链表的首节点（不知叫法是否准确）

从定义上严格来说头节点head本身并没有值，它只是一个指向首节点1的指针。也就是说head.val为空，head.next.val=1。即head的下一个节点才是1的节点。那上述的链表就有7个节点（包含头节点head）。

但是，在一些编程题里，有可能把头节点默认为首节点。也就是说head不仅指向1，而且head.val=1，那head.next.val=2。即head就是1的节点，head的下一个节点是2的节点。那么这个链表一个就有6个节点（head和1所在的节点看作一个节点）。
1(head)     2     3     4     5     6
因此，若定义一个Listnode  ptr = head；则ptr.val = 1
有时我们需要定义一个辅助节点
        ListNode now = new ListNode(-1);
        now.next = head;
这表示定义一个节点now，它没有值，它指向头节点head。
```

